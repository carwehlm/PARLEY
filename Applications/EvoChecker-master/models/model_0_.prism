dtmc
const int N=4;
const int xstart = 0;
const int ystart = 0;
const int xtarget = 4;
const int ytarget = 4;
const double p = 0.01;
 
formula hasCrashed = (1=0) | (x=0 & y=1) | (x=0 & y=2) | (x=1 & y=1) | (x=1 & y=4) | (x=3 & y=1) | (x=4 & y=1) ;

module Robot 
  x : [0..N] init xstart;
  y : [0..N] init ystart;
  move_ready : [0..1] init 1;
  crashed : [0..1] init 0;

  [east] (move_ready=1) -> 
    (1-3*p): (x'=min(x+1, N)) & (move_ready'=0) + 
    p: (y'=min(y+1, N)) & (move_ready'=0) + 
    p: (y'=max(y-1, 0)) & (move_ready'=0) + 
    p: (x'=max(x-1, 0)) & (move_ready'=0); 
  [west] (move_ready=1) -> 
    p: (x'=min(x+1, N)) & (move_ready'=0) + 
    p: (y'=min(y+1, N)) & (move_ready'=0) + 
    p: (y'=max(y-1, 0)) & (move_ready'=0) + 
    (1-3*p): (x'=max(x-1, 0)) & (move_ready'=0); 
  [north] (move_ready=1) -> 
    p: (x'=min(x+1, N)) & (move_ready'=0) + 
    (1-3*p): (y'=min(y+1, N)) & (move_ready'=0) + 
    p: (y'=max(y-1, 0)) & (move_ready'=0) + 
    p: (x'=max(x-1, 0)) & (move_ready'=0); 
  [south] (move_ready=1) -> 
    p: (x'=min(x+1, N)) & (move_ready'=0) + 
    p: (y'=min(y+1, N)) & (move_ready'=0) + 
    (1-3*p): (y'=max(y-1, 0)) & (move_ready'=0) + 
    p: (x'=max(x-1, 0)) & (move_ready'=0); 

  [check] (move_ready=0) & hasCrashed -> (crashed'=1) & (move_ready'=1); 
  [check] (move_ready=0) & !hasCrashed -> (move_ready'=1); 
endmodule

module Adaptation_MAPE_controller
  [east] (xhat=0) & (yhat=0) -> true;
  [east] (xhat=0) & (yhat=3) -> true;
  [south] (xhat=0) & (yhat=4) -> true;
  [east] (xhat=1) & (yhat=0) -> true;
  [east] (xhat=1) & (yhat=2) -> true;
  [east] (xhat=1) & (yhat=3) -> true;
  [north] (xhat=2) & (yhat=0) -> true;
  [north] (xhat=2) & (yhat=1) -> true;
  [north] (xhat=2) & (yhat=2) -> true;
  [east] (xhat=2) & (yhat=3) -> true;
  [east] (xhat=2) & (yhat=4) -> true;
  [west] (xhat=3) & (yhat=0) -> true;
  [north] (xhat=3) & (yhat=2) -> true;
  [north] (xhat=3) & (yhat=3) -> true;
  [east] (xhat=3) & (yhat=4) -> true;
  [west] (xhat=4) & (yhat=0) -> true;
  [north] (xhat=4) & (yhat=2) -> true;
  [north] (xhat=4) & (yhat=3) -> true;
endmodule

module Knowledge
  xhat : [0..N] init xstart;
  yhat : [0..N] init ystart;
  step : [1..20] init 1;

  ready : [0..1] init 1;
  [west] ready=1 -> (xhat'=max(xhat-1, 0)) & (ready'=0);
  [east] ready=1 -> (xhat'=min(xhat+1, N)) & (ready'=0);
  [south] ready=1 -> (yhat'=max(yhat-1, 0)) & (ready'=0);
  [north] ready=1 -> (yhat'=min(yhat+1, N)) & (ready'=0);
  [update] step>=c & ready=0 -> (xhat'=x) & (yhat'=y) & (step'=1) & (ready'=1);
  [skip_update] step<c & ready=0 -> (ready'=1) & (step'=step+1);
endmodule

rewards "cost" 
  [east] true : 1; 
  [west] true : 1; 
  [north] true : 1; 
  [south] true : 1; 
  [update] true : 5;
endrewards 


const int decision_0_0=1;
const int decision_0_1=1;
const int decision_0_2=1;
const int decision_0_3=1;
const int decision_0_4=1;
const int decision_1_0=1;
const int decision_1_1=1;
const int decision_1_2=1;
const int decision_1_3=1;
const int decision_1_4=1;
const int decision_2_0=1;
const int decision_2_1=1;
const int decision_2_2=1;
const int decision_2_3=1;
const int decision_2_4=1;
const int decision_3_0=1;
const int decision_3_1=1;
const int decision_3_2=1;
const int decision_3_3=1;
const int decision_3_4=1;
const int decision_4_0=1;
const int decision_4_1=1;
const int decision_4_2=1;
const int decision_4_3=1;
const int decision_4_4=1;const int one=1;

module URC
  c : [1..10] init decision_0_0;
  [URC] one=1 & xhat=0 & yhat=0 -> (c'=decision_0_0);
  [URC] one=1 & xhat=0 & yhat=1 -> (c'=decision_0_1);
  [URC] one=1 & xhat=0 & yhat=2 -> (c'=decision_0_2);
  [URC] one=1 & xhat=0 & yhat=3 -> (c'=decision_0_3);
  [URC] one=1 & xhat=0 & yhat=4 -> (c'=decision_0_4);
  [URC] one=1 & xhat=1 & yhat=0 -> (c'=decision_1_0);
  [URC] one=1 & xhat=1 & yhat=1 -> (c'=decision_1_1);
  [URC] one=1 & xhat=1 & yhat=2 -> (c'=decision_1_2);
  [URC] one=1 & xhat=1 & yhat=3 -> (c'=decision_1_3);
  [URC] one=1 & xhat=1 & yhat=4 -> (c'=decision_1_4);
  [URC] one=1 & xhat=2 & yhat=0 -> (c'=decision_2_0);
  [URC] one=1 & xhat=2 & yhat=1 -> (c'=decision_2_1);
  [URC] one=1 & xhat=2 & yhat=2 -> (c'=decision_2_2);
  [URC] one=1 & xhat=2 & yhat=3 -> (c'=decision_2_3);
  [URC] one=1 & xhat=2 & yhat=4 -> (c'=decision_2_4);
  [URC] one=1 & xhat=3 & yhat=0 -> (c'=decision_3_0);
  [URC] one=1 & xhat=3 & yhat=1 -> (c'=decision_3_1);
  [URC] one=1 & xhat=3 & yhat=2 -> (c'=decision_3_2);
  [URC] one=1 & xhat=3 & yhat=3 -> (c'=decision_3_3);
  [URC] one=1 & xhat=3 & yhat=4 -> (c'=decision_3_4);
  [URC] one=1 & xhat=4 & yhat=0 -> (c'=decision_4_0);
  [URC] one=1 & xhat=4 & yhat=1 -> (c'=decision_4_1);
  [URC] one=1 & xhat=4 & yhat=2 -> (c'=decision_4_2);
  [URC] one=1 & xhat=4 & yhat=3 -> (c'=decision_4_3);
  [URC] one=1 & xhat=4 & yhat=4 -> (c'=decision_4_4);
endmodule
module Turn
  t : [0..2] init 0;
  [east] (t=0) -> (t'=1);
  [west] (t=0) -> (t'=1);
  [north] (t=0) -> (t'=1);
  [south] (t=0) -> (t'=1);

  [URC] (t=1) -> (t'=2);

  [update] (t=2) -> (t'=0);
  [skip_update] (t=2) -> (t'=0);
endmodule
