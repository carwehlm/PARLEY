dtmc

//failure prob for s1 causing one time failure
const double p1_1 = 0.1;
//failure prob for s1 causing persistent failure
const double p1_2 = 0.2;
//repair prob for s1 persistent failure
const double p1_3 = 0.3;
//failure prob for s2 causing one time failure
const double p2_1 = 0.3;
//failure prob for s2 causing persistent failure
const double p2_2 = 0.1;
//repair prob for s2 persistent failure
const double p2_3 = 0.4;
//probability for alarm
const double p=0.25;

const int c1=1;
const int c2=1;

const int iterations=50;

module service1
  // 0 means works, 1 means fails, 2 means persistent failure
  s1 : [0..2] init 0;
  [setService1] s1=0 -> 
    p1_1: (s1'=1) +
    p1_2: (s1'=2) + 
    1- p1_1 - p1_2 : true;

  [setService1] s1=1 -> (s1'=0);

  [setService1] s1=2 -> 
    p1_3: (s1'=2) + 
    1- p1_3 : true;
endmodule

module service2
  // 0 means works, 1 means fails, 2 means persistent failure
  s2 : [0..2] init 0;
  [setService2] s2=0 -> 
    p2_1: (s2'=1) +
    p2_2: (s2'=2) + 
    1- p2_1 - p2_2 : true;

  [setService2] s2=1 -> (s2'=0);

  [setService2] s2=2 -> 
    p2_3: (s2'=2) + 
    1- p2_3 : true;
endmodule

module Patient
  setAlarm : [0..1] init 0; 
  [alarm] true -> 
    p: (setAlarm'=1) +
    1-p: (setAlarm'=0);

    [resetAlarm] true -> (setAlarm'=0);
endmodule


//determines which service to invoke in case of alarm
module Adaptation_MAPE_Controller
  //here we're modelling that an alarm is issued via the service
  [invokes1] s1_hat=0 -> true;
  [invokes2] s1_hat>0 -> true;
endmodule

module Knowledge
  s1_hat : [0..1] init 0;
  s2_hat : [0..1] init 0;
  s1_c : [1..11] init 1;
  s2_c : [1..11] init 1;
  
  [setService1] true -> (s1_c'=min(s1_c+1, 11));
  [setService2] true -> (s2_c'=min(s2_c+1, 11));


  [probe_s1] s1>0 & s1_c>c1 -> (s1_hat'=1) & (s1_c'=1);
  [probe_s1] s1=0 & s1_c>c1 -> (s1_hat'=0) & (s1_c'=1);
  [skip_probe] t=2 & s1_c<=c1 -> true;

  [probe_s2] s2>0 & s2_c>c2 -> (s2_hat'=1) & (s2_c'=1);
  [probe_s2] s2=0 & s2_c>c2 -> (s2_hat'=0) & (s2_c'=1);
  [skip_probe] t=3 & s2_c<=c2 -> true;


  [invokes1] setAlarm>0 -> true;
  [invokes2] setAlarm>0 -> true;
  [skip] setAlarm=0 -> true;


endmodule

module turn

  t : [0..6] init 0;
  counter : [0..201] init 0;
  [setService1] t=0 & counter<iterations -> (t'=t+1) & (counter'=counter+1);
  [setService2] t=1 -> (t'=t+1);


  //this is to resolve uncertainty
  [probe_s1] t=2 -> (t'=t+1);
  [skip_probe] t=2 -> (t'=t+1);
  [probe_s2] t=3 -> (t'=t+1);
  [skip_probe] t=3 -> (t'=t+1);

  [alarm] t=4 -> (t'=t+1);

  //this is to call for alarm
  [invokes1] t=5 -> (t'=0);
  [invokes2] t=5 -> (t'=0);
  [skip] t=5 -> (t'=0);


endmodule

module monitor 
  invokeds1 : [0..1] init 0;
  invokeds2 : [0..1] init 0;
  [invokes1] true -> (invokeds1'=1);
  [setService1] true -> (invokeds1'=0);
  [invokes2] true -> (invokeds2'=1);
  [setService2] true -> (invokeds2'=0);
endmodule

rewards "cost"
  [invokes1] true: 1;
  [invokes2] true: 2;
  [probe_s1] true: 1;
  [probe_s2] true: 2;
endrewards

rewards "service"
  [invokes1] s1=0 : 10;
  [invokes2] s2=0 : 10;
endrewards

